<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Why Not Wingnut?</title><link href="http://nathanielca.se/" rel="alternate"></link><link href="http://nathanielca.se/feeds/tag/mediagoblin.atom.xml" rel="self"></link><id>http://nathanielca.se/</id><updated>2015-04-29T16:33:46-04:00</updated><entry><title>Deploying MediaGoblin 2: SELinux</title><link href="http://nathanielca.se/fossrit/deploying-mediagoblin-2-selinux.html" rel="alternate"></link><updated>2015-04-29T16:33:46-04:00</updated><author><name>Nathaniel Case</name></author><id>tag:nathanielca.se,2015-04-29:fossrit/deploying-mediagoblin-2-selinux.html</id><summary type="html">&lt;p&gt;So, &lt;a class="reference external" href="deploying-mediagoblin-1-fastcgi-vs-uwsgi.html"&gt;earlier&lt;/a&gt;, I wrote about my experience deploying &lt;a class="reference external" href="http://mediagoblin.org"&gt;MediaGoblin&lt;/a&gt;. None of
this was necessary, I was mostly trying to diagnose some problems I was having
and found uWSGI a more comfortable environment than FastCGI.&lt;/p&gt;
&lt;p&gt;And what problem was this, you ask? Well, when I first ran through the
installation instructions, everything worked swimmingly (the port issues
mentioned aside). The server it was running on, however, was running Fedora 17,
while Fedora 20 has just reached alpha status recently. So, in the interest of
retaining compatibility and security fixes, there was a fun afternoon of double
distribution updates.&lt;/p&gt;
&lt;p&gt;At first, everything seemed to be working fine, but then MediaGoblin began
inexplicably throwing 'permission denied' errors. As usually happens in these
cases, the culprit was SELinux, an additional security layer which normally
transparently protects your system, until something unexpected shows up.&lt;/p&gt;
&lt;p&gt;I don't pretend to understand SELinux, but I do understand the security
improvements it brings. Plus I don't want to disable it on a system I don't
own.&lt;/p&gt;
&lt;p&gt;Long, boring story short (and it was very long, being noticed first, and not
fixed until well after I figured out how to get uWSGI running), I got something
reasonably close to what I think I'm supposed to do. The key was the command
&lt;tt class="docutils literal"&gt;setsebool &lt;span class="pre"&gt;-P&lt;/span&gt; httpd_can_network_connect on&lt;/tt&gt;, which re-enabled the ability for
nginx to talk to programs on a network socket, as in the MediaGoblin
documentation.&lt;/p&gt;
&lt;p&gt;I initially changed to a file-based Unix socket, but I could not, for the life
of me figure out how to enable this simply without changing a large number of
SELinux booleans. There may be some simpler way of accomplishing this, but alas,
in this case SELinux has once again bested me.&lt;/p&gt;
</summary><category term="mediagoblin"></category><category term="yacht"></category><category term="SELinux"></category></entry><entry><title>Deploying MediaGoblin 1: FastCGI vs uWSGI</title><link href="http://nathanielca.se/fossrit/deploying-mediagoblin-1-fastcgi-vs-uwsgi.html" rel="alternate"></link><updated>2013-09-23T13:20:00-04:00</updated><author><name>Nathaniel Case</name></author><id>tag:nathanielca.se,2013-09-23:fossrit/deploying-mediagoblin-1-fastcgi-vs-uwsgi.html</id><summary type="html">&lt;p&gt;Last week I did a thing I really wasn't expecting to. I deployed
&lt;a class="reference external" href="http://mediagoblin.org"&gt;MediaGoblin&lt;/a&gt; to FOSS&amp;#64;RIT's yacht server &lt;a class="reference external" href="http://yacht.rit.edu/mediagoblin/"&gt;here&lt;/a&gt;. The initial setup and
&lt;a class="reference external" href="https://mediagoblin.readthedocs.org/en/v0.5.0/siteadmin/deploying.html"&gt;instructions&lt;/a&gt; are some of the clearest and straightforward I have seen in an
open-source project.&lt;/p&gt;
&lt;p&gt;There are several reasons I haven't written this up earlier. One of the reasons
was the web server configuration file was more complex than I was used to, so
in order to get the server running quickly, I made a new config file for port
8080. Unfortunately, due to various arcane networking policies, while this
allowed anyone inside RIT to access the server, it was still not available to
the outside world.&lt;/p&gt;
&lt;p&gt;Also, though the instructions were very clear, they used a few things I had not
used before, and a few things that weren't used in the way I was used to them.
This is the first blog post on the subject, detailing my confusion with
FastCGI and its eventual replacement with uWSGI.&lt;/p&gt;
&lt;div class="section" id="what-the-flup"&gt;
&lt;h2&gt;What the &lt;tt class="docutils literal"&gt;flup&lt;/tt&gt;?&lt;/h2&gt;
&lt;p&gt;MediaGoblin, as documented, uses FastCGI to route requests from the web server
to MediaGoblin. The CGI in FastCGI refers to the 'Common Gateway Interface',
a standard developed to allow web servers to act as 'gateways' to serve not
just files but the output of executable programs. The MediaGoblin docs describe
how to use a python module called &lt;tt class="docutils literal"&gt;flup&lt;/tt&gt; to enable this communication.&lt;/p&gt;
&lt;p&gt;There's a bit more to it than that, but in Python land, this
turns out to be a more questionable prospect than it might seem. Python already
has its own gateway interface (called the web server gateway interface, or
WSGI) which it is using to talk to FastCGI to have the WSGI turned into CGI so
that it can be interpreted by the server and turned into a web page. This would
be fine except that there are other WSGI-specific modules which can translate
the WSGI into a web page directly.&lt;/p&gt;
&lt;p&gt;At this point, I assume that you are either skipping ahead past things you
already know or are horribly lost, so I'll just say that I eventually moved
MediaGoblin from the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;paste-&amp;gt;flup-&amp;gt;FastCGI-&amp;gt;nginx&lt;/span&gt;&lt;/tt&gt; contraption it was to a more
comprehensible &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;uWSGI-&amp;gt;nginx&lt;/span&gt;&lt;/tt&gt;, and this is how I did it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="enter-uwsgi"&gt;
&lt;h2&gt;Enter uWSGI&lt;/h2&gt;
&lt;p&gt;First, I changed the nginx config to talk to uWSGI instead of FastCGI.
As I was also trying to move MediaGoblin to a subdirectory, I also added the
&lt;tt class="docutils literal"&gt;uWSGI_modifier1&lt;/tt&gt; line and altered &lt;tt class="docutils literal"&gt;SCRIPT_NAME&lt;/tt&gt; accordingly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;# Load MediaGoblin via uWSGI&lt;/span&gt;
&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/mediagoblin/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;uWSGI_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kn"&gt;uWSGI_pass&lt;/span&gt; &lt;span class="n"&gt;127.0.0.1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;26543&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="c1"&gt;# our understanding vs nginx&amp;#39;s handling of script_name vs&lt;/span&gt;
   &lt;span class="c1"&gt;# path_info don&amp;#39;t match :)&lt;/span&gt;
   &lt;span class="kn"&gt;uWSGI_param&lt;/span&gt; &lt;span class="s"&gt;SCRIPT_NAME&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/mediagoblin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kn"&gt;uWSGI_modifier1&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Second, I altered the &lt;tt class="docutils literal"&gt;lazystarter.sh&lt;/tt&gt; file to accommodate being run with
uWSGI. This is a bit complicated as &lt;tt class="docutils literal"&gt;lazyserver.sh&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;lazystarter.sh&lt;/tt&gt;, and
&lt;tt class="docutils literal"&gt;lazycelery.sh&lt;/tt&gt; are all actually the same file, with certain things changing
depending on the name by which it is invoked. I changed two sections &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[1]&lt;/a&gt;,
first:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;local_bin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;./bin&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$selfname&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    lazyserver.sh&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;starter_cmd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;paster
        &lt;span class="nv"&gt;ini_prefix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;paste
        &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;became:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;local_bin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;./bin&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$selfname&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    lazyserver.sh&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;starter_cmd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;uwsgi
        &lt;span class="nv"&gt;ini_prefix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;paste
        &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then near the very end of the file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;CELERY_ALWAYS_EAGER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$selfname&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    lazyserver.sh&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;$starter&lt;/span&gt; serve &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$ini_file&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; --reload
        &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;became:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;CELERY_ALWAYS_EAGER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$selfname&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    lazyserver.sh&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;$starter&lt;/span&gt; --plugin python --virtualenv . --ini-paste &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$ini_file&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This method allows you to keep using all the information on how to run
MediaGoblin from paste.ini, while using uWSGI to do all the heavy lifting.
The socket still needs to be defined with the command, though, with
&lt;tt class="docutils literal"&gt;./lazyserver.sh &lt;span class="pre"&gt;--socket&lt;/span&gt; 127.0.0.1:26543&lt;/tt&gt; or whatever socket you are using.&lt;/p&gt;
&lt;p&gt;As a side note, this also allows us to use your system's uWSGI &lt;a class="reference external" href="http://uWSGI-docs.readthedocs.org/en/latest/Emperor.html"&gt;emperor&lt;/a&gt; to
manage bringing up the uWSGI process for you. If you are running &lt;a class="reference external" href="http://mediagoblin.readthedocs.org/en/v0.5.0/siteadmin/production-deployments.html#separate-celery"&gt;celery as a
separate process&lt;/a&gt;, this still needs to be done somehow, but otherwise (or if
you've kept &lt;tt class="docutils literal"&gt;CELERY_ALWAYS_EAGER=true&lt;/tt&gt;), then MediaGoblin should be managed
automatically. This is the format I eventually settled upon, using the
following uWSGI ini file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[uwsgi]&lt;/span&gt;
&lt;span class="na"&gt;plugin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;python&lt;/span&gt;
&lt;span class="na"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;mediagoblin&lt;/span&gt;
&lt;span class="na"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;mediagoblin&lt;/span&gt;
&lt;span class="na"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;127.0.0.1:26543&lt;/span&gt;
&lt;span class="na"&gt;virtualenv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/srv/www/mediagoblin&lt;/span&gt;
&lt;span class="na"&gt;chdir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/srv/www/mediagoblin&lt;/span&gt;
&lt;span class="na"&gt;ini-paste&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/srv/www/mediagoblin/paste.ini&lt;/span&gt;
&lt;span class="na"&gt;logto&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/srv/www/mediagoblin/mg.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-next"&gt;
&lt;h2&gt;What Next?&lt;/h2&gt;
&lt;p&gt;As far as I can tell, this should have been all we needed to get running.
Well, this wouldn't have been necessary either, except for some of the
repercussions of the other big problem that reared it's head, SELinux.&lt;/p&gt;
&lt;p&gt;But that is &lt;a class="reference external" href="deploying-mediagoblin-2-selinux.html"&gt;another post&lt;/a&gt;.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This statement is not entirely accurate. I actually made a new link
named &lt;tt class="docutils literal"&gt;lazyuwsgi.sh&lt;/tt&gt; and added the sections instead of altering the
existing ones. This format was chosen for clarity.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="mediagoblin"></category><category term="yacht"></category><category term="uWSGI"></category></entry></feed>